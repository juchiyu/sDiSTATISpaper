---
title: "0.2_sparseDiSTATIS"
author: "Ju-Chi.Yu"
date: "12/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r cars, echo = FALSE, include = FALSE}
suppressMessages(library(psych))
suppressMessages(library(DistatisR)) # 
suppressMessages(library(tidyr))
suppressMessages(library(magrittr))
suppressMessages(library(data4PCCAR))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ggplot2))
suppressMessages(library(ExPosition))
suppressMessages(library(InPosition))
suppressMessages(library(superheat))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplotify))
suppressMessages(library(grid))
suppressMessages(library(viridis))
suppressMessages(library(pals))
library(sGSVD)
library(SPAFAC)
# Read functions
tool.path <- "functions/"

source(paste0(tool.path, "PlotMyScree.R"))
```
#### Other functions

```{r}
DiStatis.preproc <- function(Dist.mat){ # start of function DiStatis.preproc
  # (1) preprocessing as MDS
  ## masses
  M_vec <- rep(1/nrow(Dist.mat), nrow(Dist.mat)) # sum of M_vec = 1
  ## centering matrix
  Cm <- diag(rep(1,dim(Dist.mat)[1])) - (as.matrix(rep(1,dim(Dist.mat)[1])) %*% t(M_vec))
  ## cross-product matrix
  S <- -0.5*(Cm %*% Dist.mat %*% t(Cm)) # ... different from [X %*% t(X)]
  # (2) devided by the first eigen value
  Lambda <- eigen(S)$values[1]
  S.hat <- S/Lambda
  # output
  return(S.hat)
} # end of function DiStatis.preproc

```


## Create design matrix

```{r}
data("sortingWines")

wine.dx <- sortingWines$winesDescription

free.exp <- sortingWines$freeSortExperts
colnames(free.exp) <- paste0(colnames(sortingWines$freeSortExperts), ".freEx")
tern.exp <- sortingWines$ternarySortExperts
colnames(tern.exp) <- paste0(colnames(sortingWines$ternarySortExperts), ".terEx")
tern.nov <- sortingWines$ternarySortNovices
colnames(tern.nov) <- paste0(colnames(sortingWines$ternarySortNovices), ".terNv")

gtab <- cbind(free.exp, tern.exp, tern.nov)
exp.dx <- sub('.*\\.', "", colnames(gtab))

exp.col <- createColorVectorsByDesign(makeNominalData(as.matrix(exp.dx)))
rownames(exp.col$gc) <- sub('.*\\.', "", rownames(exp.col$gc))

DisCube <- DistanceFromSort(gtab)
```

## DiSTATIS

### Analysis
```{r}
distatis.res <- distatis(DisCube)

BootF <- BootFactorScores(distatis.res$res4Splus$PartialF)
F_fullBoot <- BootFromCompromise(DisCube,niter=1000)
```

### Results

#### RV space
```{r, fig.show="hold", out.width = '50%'}
C.eigres <- data.frame(eig = distatis.res$res4Cmat$eigValues, tau = distatis.res$res4Cmat$tau)
PlotMyScree(C.eigres, cex = 2)

Cmap <- createFactorMap(distatis.res$res4Cmat$G, 
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = exp.col$oc,
                        col.labels = exp.col$oc)

Cmap$zeMap
```

#### Compromise
```{r, fig.show="hold", out.width='50%'}
S.eigres <- data.frame(eig = distatis.res$res4Splus$eigValues, tau = distatis.res$res4Splus$tau)
PlotMyScree(S.eigres, cex = 2)

Smap <- createFactorMap(distatis.res$res4Splus$F,
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = wine.dx$ColorCode,
                        col.labels = wine.dx$ColorCode)

Smap$zeMap
```

## Sparsification {.tabset}

We first preprocess the distance matrices: double-centered and MFA-normalized

```{r}
DisCube.proc <- apply(DisCube, 3, DiStatis.preproc, simplify = FALSE)
```


### RV only

```{r}
I.c <- nrow(distatis.res$res4Cmat$C)

rv.speig <- sparseEIGEN(X = distatis.res$res4Cmat$C, k = 5L, init = "svd", rds = rep(0.5*sqrt(I.c), 5))

rv.spC <- list(pdq = list(eig = rv.speig$values,
                          U = rv.speig$vectors),
               tau = rv.speig$values/sum(distatis.res$res4Cmat$tau),
               G = rv.speig$vectors %*% diag(sqrt(rv.speig$values)),
               alpha = rv.speig$vectors[,1]/sum(rv.speig$vectors[,1])
)



## weight the preprocessed matrix by alpha
DisCube.S <- sapply(1:64, function(x) rv.spC$alpha[x]*DisCube.proc[[x]], simplify = FALSE)

## compute the compromise (Splus)
DisCube.S.array <- array(as.numeric(unlist(DisCube.S)), dim = c(18,18,64))
rv.Splus <- apply(DisCube.S.array, c(1,2), sum)
rownames(rv.Splus) <- colnames(rv.Splus) <- rownames(DisCube)

## eigen decomposition of the compromise
rv.S.eig <- eigen(rv.Splus)
rv.S.eig$values[rv.S.eig$values < 0] <- 0
rv.S <- list(pdq = list(eig = rv.S.eig$values,
                            U = rv.S.eig$vectors),
                 tau = rv.S.eig$values/sum(rv.S.eig$values), # with respective to its own inertia
                 f = rv.S.eig$vectors %*% diag(sqrt(rv.S.eig$values)))
```

#### RV space
```{r, fig.show="hold", out.width = '50%'}
rv.spC.eigres <- data.frame(eig = rv.spC$pdq$eig, tau = rv.spC$tau)
PlotMyScree(rv.spC.eigres, cex = 2)

rv.Cmap <- createFactorMap(rv.spC$G, 
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = exp.col$oc,
                        col.labels = exp.col$oc)

rv.Cmap$zeMap
```

#### Compromise
```{r, fig.show="hold", out.width='50%'}
rv.S.eigres <- data.frame(eig = rv.S$pdq$eig, tau = rv.S$tau)
PlotMyScree(rv.S.eigres, cex = 2)

rv.Smap <- createFactorMap(rv.S$f,
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = wine.dx$ColorCode,
                        col.labels = wine.dx$ColorCode)

rv.Smap$zeMap
```

### Compromise only

```{r}
I.s <- nrow(distatis.res$res4Splus$Splus)

## eigen decomposition of the compromise
cmp.S.eig <- sparseEIGEN(X = distatis.res$res4Splus$Splus, k = 5L, init = "svd", rds = rep(0.5*sqrt(I.s), 5))
cmp.Splus <- list(pdq = list(eig = cmp.S.eig$values,
                            U = cmp.S.eig$vectors),
                 tau = cmp.S.eig$values/sum(distatis.res$res4Splus$eigValues), # with respective to its own inertia before sparsification
                 f = cmp.S.eig$vectors %*% diag(sqrt(cmp.S.eig$values)))

```

#### RV space
```{r, fig.show="hold", out.width='50%'}
PlotMyScree(C.eigres, cex = 2)
Cmap$zeMap
```

#### Compromise
```{r, fig.show="hold", out.width='50%'}
cmp.S.eigres <- data.frame(eig = cmp.Splus$pdq$eig, tau = cmp.Splus$tau)
PlotMyScree(cmp.S.eigres, cex = 2)

cmp.Smap <- createFactorMap(cmp.Splus$f,
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = wine.dx$ColorCode,
                        col.labels = wine.dx$ColorCode)

cmp.Smap$zeMap
```


### RV (only Component 1) + Compromise

> I need to reconstruct the compromise (Splus) after sparsifying the RV space, because the Splus from the sparsified RV space gives negative eigenvalues (close to 0). I reconstruct the compromise by replacing these values with 0s.

```{r}
## reconstruct rv.Splus
rv.Splus.cor <- t(rv.S.eig$vector) %*% diag(rv.S.eig$values) %*% rv.S.eig$vectors

## reuse the Splus from sparsified RV
I.s <- nrow(rv.Splus.cor)

## eigen decomposition of the compromise
rvcmp.S.eig <- sparseEIGEN(X = rv.Splus.cor, k = 5L, init = "svd", rds = rep(0.5*sqrt(I.s), 5))
rvcmp.S <- list(pdq = list(eig = rvcmp.S.eig$values,
                            U = rvcmp.S.eig$vectors),
                 tau = rvcmp.S.eig$values/sum(rv.S.eig$values), # with respective to its own inertia when the compromise is not sparsified
                 f = rvcmp.S.eig$vectors %*% diag(sqrt(rvcmp.S.eig$values)))
```

#### RV space
```{r, fig.show="hold", out.width='50%'}
PlotMyScree(rv.spC.eigres, cex = 2)
rv.Cmap$zeMap
```

#### Compromise
```{r, fig.show="hold", out.width='50%'}
rvcmp.S.eigres <- data.frame(eig = rvcmp.S$pdq$eig, tau = rvcmp.S$tau)
PlotMyScree(rvcmp.S.eigres, cex = 2)

rvcmp.Smap <- createFactorMap(rvcmp.S$f,
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = wine.dx$ColorCode,
                        col.labels = wine.dx$ColorCode)

rvcmp.Smap$zeMap
```