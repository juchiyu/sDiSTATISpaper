---
title: "Sparse DiSTATIS with more than two dimensions"
author: "Ju-Chi.Yu & Vincent Guillemot"
date: "12/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r cars, echo = FALSE, include = FALSE}
suppressMessages(library(psych))
suppressMessages(library(DistatisR)) # 
suppressMessages(library(tidyr))
suppressMessages(library(magrittr))
suppressMessages(library(data4PCCAR))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ggplot2))
suppressMessages(library(ExPosition))
suppressMessages(library(InPosition))
suppressMessages(library(superheat))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplotify))
suppressMessages(library(grid))
suppressMessages(library(viridis))
suppressMessages(library(pals))
devtools::load_all("~/git/sGSVD")
library(SPAFAC)
# Read functions
tool.path <- "functions/"

source(paste0(tool.path, "PlotMyScree.R"))
```
#### Other functions

```{r}
DiStatis.preproc <- function(Dist.mat){ # start of function DiStatis.preproc
  # (1) preprocessing as MDS
  ## masses
  M_vec <- rep(1/nrow(Dist.mat), nrow(Dist.mat)) # sum of M_vec = 1
  ## centering matrix
  Cm <- diag(rep(1,dim(Dist.mat)[1])) - (as.matrix(rep(1,dim(Dist.mat)[1])) %*% t(M_vec))
  ## cross-product matrix
  S <- -0.5*(Cm %*% Dist.mat %*% t(Cm)) # ... different from [X %*% t(X)]
  # (2) devided by the first eigen value
  Lambda <- eigen(S)$values[1]
  S.hat <- S/Lambda
  # output
  return(S.hat)
} # end of function DiStatis.preproc

```


## Create design matrix

```{r}
data("sortingWines")

wine.dx <- sortingWines$winesDescription

free.exp <- sortingWines$freeSortExperts
colnames(free.exp) <- paste0(colnames(sortingWines$freeSortExperts), ".freEx")
tern.exp <- sortingWines$ternarySortExperts
colnames(tern.exp) <- paste0(colnames(sortingWines$ternarySortExperts), ".terEx")
tern.nov <- sortingWines$ternarySortNovices
colnames(tern.nov) <- paste0(colnames(sortingWines$ternarySortNovices), ".terNv")

gtab <- cbind(free.exp, tern.exp, tern.nov)
exp.dx <- sub('.*\\.', "", colnames(gtab))



exp.col <- createColorVectorsByDesign(makeNominalData(as.matrix(exp.dx)))
rownames(exp.col$gc) <- sub('.*\\.', "", rownames(exp.col$gc))

DisCube <- DistanceFromSort(gtab)


nbcomp <- factor(ifelse(unname(apply(gtab, 2, max) <= 3), "LessThan3", "MoreThan3"))
nbcomp.col <- c("darkorchid4", "darkolivegreen")[nbcomp]


```

## DiSTATIS

### Analysis

```{r distatis}
# distatis.res <- distatis(DisCube)
# BootF <- BootFactorScores(distatis.res$res4Splus$PartialF)
# F_fullBoot <- BootFromCompromise(DisCube,niter=1000)
```

### Results

#### RV space
```{r, fig.show="hold", out.width = '50%'}
C.eigres <- data.frame(eig = distatis.res$res4Cmat$eigValues, tau = distatis.res$res4Cmat$tau)
PlotMyScree(C.eigres, cex = 2)

Cmap <- createFactorMap(distatis.res$res4Cmat$G, 
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = exp.col$oc,
                        col.labels = exp.col$oc)

Cmap$zeMap


Cmap2 <- createFactorMap(distatis.res$res4Cmat$G, 
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = nbcomp.col,
                        col.labels = nbcomp.col)

Cmap2$zeMap
```

#### Compromise
```{r, fig.show="hold", out.width='50%'}
S.eigres <- data.frame(eig = distatis.res$res4Splus$eigValues, tau = distatis.res$res4Splus$tau)
PlotMyScree(S.eigres, cex = 2)

Smap <- createFactorMap(distatis.res$res4Splus$F,
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = wine.dx$ColorCode,
                        col.labels = wine.dx$ColorCode)

Smap$zeMap
```

## Sparsification {.tabset}

We first preprocess the distance matrices: double-centered and MFA-normalized

```{r}
DisCube.proc <- apply(DisCube, 3, DiStatis.preproc, simplify = FALSE)
```


### RV only

```{r}
I.c <- nrow(distatis.res$res4Cmat$C)

RVmat <- distatis.res$res4Cmat$C

U0 <- abs(eigen(RVmat)$vectors[, 1:2])

rv.speig1 <- sparseEIGEN(X = RVmat, k = 2L, init = U0, rds = rep(0.5*sqrt(I.c), 2))

U1mirr <- rv.speig1$vectors == 0
U1mirr <- apply(U1mirr, 2, function(x) projL2(x)$x)

cbind(rv.speig1$vectors[, 1], U1mirr[, 1])

rv.speig2 <- sparseEIGEN(X = RVmat, k = 2L, init = U1mirr, rds = rep(0.5*sqrt(I.c), 2))

torem <- rv.speig1$vectors[, 1] == 0

RVmat3 <- RVmat[torem, torem]
I.c3 <- nrow(RVmat3)
all(eigen(RVmat3)$values > 0)

rv.speig3 <- sparseEIGEN(X = RVmat3, k = 2L, init = "svd", rds = rep(0.8*sqrt(I.c3), 2))

U3 <- rep(0, I.c)
U3[torem] <- rv.speig3$vectors[, 1] * 
  sign(rv.speig3$vectors[rv.speig3$vectors[, 1] != 0, 1][1])

Matrix::Matrix(as.matrix(round(data.frame(
  U1 = rv.speig1$vectors[, 1],
  U2 = rv.speig2$vectors[, 1],
  U3 = U3), 3)))


rv.spC <- list(pdq = list(eig = rv.speig$values,
                          U = rv.speig$vectors),
               tau = rv.speig$values/sum(distatis.res$res4Cmat$tau),
               G = rv.speig$vectors %*% diag(sqrt(rv.speig$values)),
               alpha = rv.speig$vectors[,1]/sum(rv.speig$vectors[,1])
)



## weight the preprocessed matrix by alpha
DisCube.S <- sapply(1:64, function(x) rv.spC$alpha[x]*DisCube.proc[[x]], simplify = FALSE)

## compute the compromise (Splus)
DisCube.S.array <- array(as.numeric(unlist(DisCube.S)), dim = c(18,18,64))
rv.Splus <- apply(DisCube.S.array, c(1,2), sum)
rownames(rv.Splus) <- colnames(rv.Splus) <- rownames(DisCube)

## eigen decomposition of the compromise
rv.S.eig <- eigen(rv.Splus)
rv.S.eig$values[rv.S.eig$values < 0] <- 0
rv.S <- list(pdq = list(eig = rv.S.eig$values,
                            U = rv.S.eig$vectors),
                 tau = rv.S.eig$values/sum(rv.S.eig$values), # with respective to its own inertia
                 f = rv.S.eig$vectors %*% diag(sqrt(rv.S.eig$values)))
```

#### RV space
```{r, fig.show="hold", out.width = '50%'}
rv.spC.eigres <- data.frame(eig = rv.spC$pdq$eig, tau = rv.spC$tau)
PlotMyScree(rv.spC.eigres, cex = 2)

rv.Cmap <- createFactorMap(rv.spC$G, 
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = nbcomp.col,
                        col.labels = nbcomp.col)

rv.Cmap$zeMap
```

#### Compromise
```{r, fig.show="hold", out.width='50%'}
rv.S.eigres <- data.frame(eig = rv.S$pdq$eig, tau = rv.S$tau)
PlotMyScree(rv.S.eigres, cex = 2)

rv.Smap <- createFactorMap(rv.S$f,
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = wine.dx$ColorCode,
                        col.labels = wine.dx$ColorCode)

rv.Smap$zeMap
```

### Compromise only

```{r}
I.s <- nrow(distatis.res$res4Splus$Splus)

## eigen decomposition of the compromise
cmp.S.eig <- sparseEIGEN(X = distatis.res$res4Splus$Splus, k = 5L, init = "svd", rds = rep(0.5*sqrt(I.s), 5))
cmp.Splus <- list(pdq = list(eig = cmp.S.eig$values,
                            U = cmp.S.eig$vectors),
                 tau = cmp.S.eig$values/sum(distatis.res$res4Splus$eigValues), # with respective to its own inertia before sparsification
                 f = cmp.S.eig$vectors %*% diag(sqrt(cmp.S.eig$values)))

```

#### RV space
```{r, fig.show="hold", out.width='50%'}
PlotMyScree(C.eigres, cex = 2)
Cmap$zeMap
```

#### Compromise
```{r, fig.show="hold", out.width='50%'}
cmp.S.eigres <- data.frame(eig = cmp.Splus$pdq$eig, tau = cmp.Splus$tau)
PlotMyScree(cmp.S.eigres, cex = 2)

cmp.Smap <- createFactorMap(cmp.Splus$f,
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = wine.dx$ColorCode,
                        col.labels = wine.dx$ColorCode)

cmp.Smap$zeMap
```


### RV (only Component 1) + Compromise

> I need to reconstruct the compromise (Splus) after sparsifying the RV space, because the Splus from the sparsified RV space gives negative eigenvalues (close to 0). I reconstruct the compromise by replacing these values with 0s.

```{r}
## reuse the Splus from sparsified RV
I.s <- nrow(rv.Splus)

## eigen decomposition of the compromise
rvcmp.S.eig <- sparseEIGEN(X = rv.Splus, k = 5L, init = "svd", rds = rep(0.6*sqrt(I.s), 5))
rvcmp.S <- list(pdq = list(eig = rvcmp.S.eig$values,
                            U = rvcmp.S.eig$vectors),
                 tau = rvcmp.S.eig$values/sum(rv.S.eig$values), # with respective to its own inertia when the compromise is not sparsified
                 f = rvcmp.S.eig$vectors %*% diag(sqrt(rvcmp.S.eig$values)))
```

#### RV space
```{r, fig.show="hold", out.width='50%'}
PlotMyScree(rv.spC.eigres, cex = 2)
rv.Cmap$zeMap
```

#### Compromise
```{r, fig.show="hold", out.width='50%'}
rvcmp.S.eigres <- data.frame(eig = rvcmp.S$pdq$eig, tau = rvcmp.S$tau)
PlotMyScree(rvcmp.S.eigres, cex = 2)

rvcmp.Smap <- createFactorMap(rvcmp.S$f,
                        col.background = NULL,
                        col.axes = "#42376B",
                        alpha.axes = 0.5,
                        col.points = wine.dx$ColorCode,
                        col.labels = wine.dx$ColorCode)

rvcmp.Smap$zeMap
```

## Subspace approach




